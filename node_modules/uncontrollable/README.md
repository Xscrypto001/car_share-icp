# uncontrollable

Wrap a controlled react component, to allow specific prop/handler pairs to be omitted by Component consumers. Uncontrollable allows you to write React components, with minimal state, and then wrap them in a component that will manage state for prop/handlers if they are excluded.

## Install

```sh
npm i -S uncontrollable
```

### Usage

If you are a bit unsure on the _why_ of this module read the next section first. If you just want to see some real-world examples, check out [React Widgets](https://github.com/jquense/react-widgets) which makes [heavy use of this strategy](https://github.com/jquense/react-widgets/blob/5d1b530cb094cdc72f577fe01abe4a02dd265400/src/Multiselect.jsx#L521).

```js
import { uncontrollable } from 'uncontrollable'
```

### API

#### `uncontrollable(Component, propHandlerHash, [methods])`

- `Component`: is a valid react component, such as the result of `createClass`
- `propHandlerHash`: define the pairs of prop/handlers you want to be uncontrollable, e.g. `{ value: 'onChange'}`
- `methods`: since uncontrollable wraps your component in another component, methods are not immediately accessible. You can proxy them through by providing the names of the methods you want to continue to expose. **You don't need this if you are using React >= v16.3.0, the ref will automatically be forwarded to the uinderlying component**

For every prop you indicate as uncontrollable, the returned component will also accept an initial, `default` value for that prop. For example, `open` can be left uncontrolled but the initial value can be set via `defaultOpen={true}` if we want it to start open.

```js
import { uncontrollable } from 'uncontrollable'

const UncontrolledCombobox = uncontrollable(Combobox, {
  value: 'onChange',
  open: 'onToggle',
  searchTerm: 'onSearch', //the current typed value (maybe it filters the dropdown list)
})
```

Since uncontrollable creates a new component that wraps your existing one, methods on your underlying component
won't be immediately accessible. In general this sort of access is not idiomatic React, but it does have its place.
The third argument of `uncontrollable()` is an optional array of method names you want uncontrollable to "pass through"
to the original component.

```js
let UncontrolledForm = uncontrollable(Form, { value: 'onChange' }, ['submit'])

//when you use a ref this will work
this.refs.myForm.submit()
```

#### `useUncontrolled(props, propsHandlerHash) => controlledProps`

A React hook that can be used in place of the above Higher order Component. It
returns a complete set of `props` which are safe to spread through to a child element.

```js
import { useUncontrolled } from 'uncontrollable'

const UncontrolledCombobox = props => {
  // filters out defaultValue, defaultOpen and returns controlled
  // versions of onChange, and onToggle.
  const controlledProps = useUncontrolled(props, {
    value: 'onChange',
    open: 'onToggle',
  })

  return <Checkbox {...controlledProps} />
}
```

### Use Case

One of the strengths of React is its extensibility model, enabled by a common practice of pushing component state as high up the tree as possible. While great for enabling extremely flexible and easy to reason about components, this can produce a lot of boilerplate to wire components up with every use. For simple components (like an input) this is usually a matter of tying the input `value` prop to a parent state property via its `onChange` handler. Here is an extremely common pattern:

```jsx
  render() {
    return (
      <input type='text'
        val